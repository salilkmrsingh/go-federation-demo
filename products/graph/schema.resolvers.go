package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"database/sql"
	"fmt"
	"products/graph/model"
)

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, name string, price float64) (*model.Product, error) {
	// SQL query for inserting a new product
	query := `INSERT INTO products (name, price) VALUES (?, ?)`

	// Execute the insert
	result, err := r.DB.ExecContext(ctx, query, name, price)
	if err != nil {
		return nil, fmt.Errorf("failed to insert product: %w", err)
	}

	// Get the last inserted ID
	id, err := result.LastInsertId()
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve inserted ID: %w", err)
	}

	// Return the created product
	product := &model.Product{
		ID:    fmt.Sprintf("%d", id), // Convert to string if your GraphQL ID type is string
		Name:  name,
		Price: price,
	}

	return product, nil
}

// UpdateProduct is the resolver for the updateProduct field.
func (r *mutationResolver) UpdateProduct(ctx context.Context, id string, input model.UpdateProduct) (*model.Product, error) {
	// Fetch current product
	row := r.DB.QueryRowContext(ctx, `
		SELECT id, name, price
		FROM products
		WHERE id = ?
	`, id)

	var (
		productID string
		name      sql.NullString
		price     sql.NullFloat64
	)

	if err := row.Scan(&productID, &name, &price); err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("product with id %s not found", id)
		}
		return nil, fmt.Errorf("failed to fetch product: %w", err)
	}

	// Update fields if provided
	newName := name.String
	if input.Name != nil {
		newName = *input.Name
	}
	newPrice := price.Float64
	if input.Price != nil {
		newPrice = *input.Price
	}

	// Apply updates in DB
	_, err := r.DB.ExecContext(ctx, `
		UPDATE products
		SET name = ?, price = ?
		WHERE id = ?
	`, newName, newPrice, id)
	if err != nil {
		return nil, fmt.Errorf("failed to update product: %w", err)
	}

	// Return the updated product
	updated := &model.Product{
		ID:    id,
		Name:  newName,
		Price: newPrice,
	}

	return updated, nil
}

// DeleteProduct is the resolver for the deleteProduct field.
func (r *mutationResolver) DeleteProduct(ctx context.Context, id string) (*model.Product, error) {
	// Fetch product before deletion
	row := r.DB.QueryRowContext(ctx, `
		SELECT id, name, price
		FROM products
		WHERE id = ?
	`, id)

	var (
		productID string
		name      sql.NullString
		price     sql.NullFloat64
	)

	if err := row.Scan(&productID, &name, &price); err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("product with id %s not found", id)
		}
		return nil, fmt.Errorf("failed to fetch product before delete: %w", err)
	}

	// Delete from DB
	_, err := r.DB.ExecContext(ctx, `
		DELETE FROM products
		WHERE id = ?
	`, id)
	if err != nil {
		return nil, fmt.Errorf("failed to delete product: %w", err)
	}

	// Return deleted product info
	deleted := &model.Product{
		ID:    productID,
		Name:  name.String,
		Price: price.Float64,
	}

	return deleted, nil
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context) ([]*model.Product, error) {
	query := `SELECT id, name, price FROM products`

	rows, err := r.DB.QueryContext(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("failed to query products: %w", err)
	}
	defer rows.Close()

	var products []*model.Product

	for rows.Next() {
		var product model.Product
		if err := rows.Scan(&product.ID, &product.Name, &product.Price); err != nil {
			return nil, fmt.Errorf("failed to scan product: %w", err)
		}
		products = append(products, &product)
	}

	// Check for iteration errors
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("row iteration error: %w", err)
	}

	return products, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
