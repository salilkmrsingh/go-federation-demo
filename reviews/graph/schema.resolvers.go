package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"database/sql"
	"fmt"
	errorhandler "reviews/errorHandler"
	"reviews/graph/model"
)

// CreateReview is the resolver for the createReview field.
func (r *mutationResolver) CreateReview(ctx context.Context, input model.NewReview) (*model.Review, error) {
	// Insert into database
	result, err := r.DB.ExecContext(ctx, `
		INSERT INTO reviews (body, author_id, product_id)
		VALUES (?, ?, ?)
	`, input.Body, input.AuthorID, input.ProductID)
	if err != nil {
		return nil, errorhandler.New("DB_ERROR", "failed to insert review")
	}

	// Optional: get the new review ID
	reviewID, err := result.LastInsertId()
	if err != nil {
		// SQLite always has an integer PK, so we can ignore if your table doesn't have `id`
		reviewID = 0
	}

	// Construct and return the Review object
	review := &model.Review{
		// You can store ID if your schema includes it
		ID:   fmt.Sprintf("%d", reviewID),
		Body: &input.Body,
		Author: &model.User{
			ID: input.AuthorID,
		},
		Product: &model.Product{
			ID: input.ProductID,
		},
	}

	return review, nil
}

// DeleteReview is the resolver for the deleteReview field.
func (r *mutationResolver) DeleteReview(ctx context.Context, id string) (*model.Review, error) {
	// First, fetch the review before deleting (to return it after deletion)
	row := r.DB.QueryRowContext(ctx, `
		SELECT id, body, author_id, product_id
		FROM reviews
		WHERE id = ?
	`, id)

	var (
		reviewID  string
		body      sql.NullString
		authorID  sql.NullString
		productID sql.NullString
	)

	if err := row.Scan(&reviewID, &body, &authorID, &productID); err != nil {
		if err == sql.ErrNoRows {
			return nil, errorhandler.New("NOT_FOUND", fmt.Sprintf("review with id %s not found", id))
		}
		return nil, errorhandler.New("DB_ERROR", "failed to fetch review before delete")
	}

	// Delete the review
	_, err := r.DB.ExecContext(ctx, `
		DELETE FROM reviews
		WHERE id = ?
	`, id)
	if err != nil {
		return nil, errorhandler.New("DB_ERROR", "failed to delete review")
	}

	// Build the review object to return
	review := &model.Review{
		ID: reviewID,
	}

	if body.Valid {
		review.Body = &body.String
	}

	if authorID.Valid {
		review.Author = &model.User{ID: authorID.String}
	}

	if productID.Valid {
		review.Product = &model.Product{ID: productID.String}
	}

	return review, nil
}

// UpdateReview is the resolver for the updateReview field.
func (r *mutationResolver) UpdateReview(ctx context.Context, id string, input model.UpdateReview) (*model.Review, error) {
	// Fetch the current review
	row := r.DB.QueryRowContext(ctx, `
		SELECT id, body, author_id, product_id
		FROM reviews
		WHERE id = ?
	`, id)

	var (
		reviewID  string
		body      sql.NullString
		authorID  sql.NullString
		productID sql.NullString
	)
	if err := row.Scan(&reviewID, &body, &authorID, &productID); err != nil {
		if err == sql.ErrNoRows {
			return nil, errorhandler.New("NOT_FOUND", fmt.Sprintf("review with id %s not found", id))
		}
		return nil, errorhandler.New("DB_ERROR", "failed to fetch review")
	}

	// Apply updates if provided
	newBody := body.String
	if input.Body != nil {
		newBody = *input.Body
	}
	newProductID := productID.String
	if input.ProductID != nil {
		newProductID = *input.ProductID
	}

	// Update in DB
	_, err := r.DB.ExecContext(ctx, `
		UPDATE reviews
		SET body = ?, product_id = ?
		WHERE id = ?
	`, newBody, newProductID, id)
	if err != nil {
		return nil, errorhandler.New("DB_ERROR", "failed to update review")
	}

	// Return the updated object
	updatedReview := &model.Review{
		ID:      id,
		Body:    &newBody,
		Author:  &model.User{ID: authorID.String},
		Product: &model.Product{ID: newProductID},
	}

	return updatedReview, nil

}

// Reviews is the resolver for the reviews field.
func (r *productResolver) Reviews(ctx context.Context, obj *model.Product) ([]*model.Review, error) {
	rows, err := r.DB.QueryContext(ctx, `
		SELECT id, body, author_id 
		FROM reviews 
		WHERE product_id = ?
	`, obj.ID)
	if err != nil {
		return nil, errorhandler.New("DB_ERROR", "failed to query reviews")
	}
	defer rows.Close()

	var reviews []*model.Review

	for rows.Next() {
		var id, body, authorID string

		if err := rows.Scan(&id, &body, &authorID); err != nil {
			return nil, errorhandler.New("DB_ERROR", "failed to scan row")
		}

		review := &model.Review{
			ID:   id,
			Body: &body,
			Author: &model.User{
				ID: authorID,
			},
			Product: obj,
		}

		reviews = append(reviews, review)
	}

	if err := rows.Err(); err != nil {
		return nil, errorhandler.New("DB_ERROR", "error iterating rows")
	}

	return reviews, nil
}

// Review is the resolver for the review field.
func (r *queryResolver) Review(ctx context.Context, id string) (*model.Review, error) {
	row := r.DB.QueryRowContext(ctx, `
		SELECT id, body, author_id, product_id
		FROM reviews
		WHERE id = ?
	`, id)

	var (
		reviewID  string
		body      sql.NullString
		authorID  sql.NullString
		productID sql.NullString
	)

	if err := row.Scan(&reviewID, &body, &authorID, &productID); err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, errorhandler.New("DB_ERROR", "failed to get review")
	}

	review := &model.Review{
		ID: reviewID,
	}
	if body.Valid {
		review.Body = &body.String
	}
	if authorID.Valid {
		review.Author = &model.User{ID: authorID.String}
	}
	if productID.Valid {
		review.Product = &model.Product{ID: productID.String}
	}

	return review, nil
}

// Author is the resolver for the author field.
func (r *reviewResolver) Author(ctx context.Context, obj *model.Review) (*model.User, error) {
	// If author ID is already known on the Review object, just return it.
	if obj.Author != nil {
		return obj.Author, nil
	}

	// Otherwise, you might look it up from the database if needed
	var authorID string
	err := r.DB.QueryRowContext(ctx, `
		SELECT author_id FROM reviews WHERE id = ?
	`, obj.ID).Scan(&authorID)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil // no author found
		}
		return nil, errorhandler.New("DB_ERROR", "failed to fetch author")
	}

	return &model.User{ID: authorID}, nil
}

// Product is the resolver for the product field.
func (r *reviewResolver) Product(ctx context.Context, obj *model.Review) (*model.Product, error) {
	// If product info is already populated in the review object, return it.
	if obj.Product != nil {
		return obj.Product, nil
	}

	// Otherwise, query from DB using review ID
	var productID string
	err := r.DB.QueryRowContext(ctx, `
		SELECT product_id FROM reviews WHERE id = ?
	`, obj.ID).Scan(&productID)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil // review not found
		}
		return nil, errorhandler.New("DB_ERROR", "failed to fetch product")
	}

	return &model.Product{ID: productID}, nil
}

// Reviews is the resolver for the reviews field.
func (r *userResolver) Reviews(ctx context.Context, obj *model.User) ([]*model.Review, error) {
	rows, err := r.DB.QueryContext(ctx, `
		SELECT id, body, product_id
		FROM reviews
		WHERE author_id = ?
	`, obj.ID)
	if err != nil {
		return nil, errorhandler.New("DB_ERROR", fmt.Sprintf("failed to query reviews for user %s", obj.ID))
	}
	defer rows.Close()

	var reviews []*model.Review

	for rows.Next() {
		var (
			id        string
			body      sql.NullString
			productID sql.NullString
		)

		if err := rows.Scan(&id, &body, &productID); err != nil {
			return nil, errorhandler.New("DB_ERROR", "failed to scan review")
		}

		review := &model.Review{
			ID:     id,
			Body:   nil,
			Author: obj,
		}

		if body.Valid {
			review.Body = &body.String
		}

		if productID.Valid {
			review.Product = &model.Product{ID: productID.String}
		}

		reviews = append(reviews, review)
	}

	if err := rows.Err(); err != nil {
		return nil, errorhandler.New("DB_ERROR", "error iterating user reviews")
	}

	return reviews, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Product returns ProductResolver implementation.
func (r *Resolver) Product() ProductResolver { return &productResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Review returns ReviewResolver implementation.
func (r *Resolver) Review() ReviewResolver { return &reviewResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type mutationResolver struct{ *Resolver }
type productResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type reviewResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
